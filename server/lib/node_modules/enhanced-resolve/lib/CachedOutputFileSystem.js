const fs = require("fs");
const pt = require("path");
// const  makeSyncFun = require("./makeSyncFun.js")
// /*拷贝目录*/
// var copyDir = function(srcDir, workdir, callback) {

//   var files = getFileList(srcDir, true);

//   for (var i = 0; files && i < files.length; i++) {
//     var tempSrc = files[i].replace(srcDir, "")
//     var tempWork = (workdir + "/" + tempSrc).replace(/\/+/g, "/")
//     copyFile(files[i], tempWork)
//   }
// }
// /*拷贝文件*/
// var copyFile = function(infile, outfile) {


//   if (isExist(infile)) {
//     if (!isExist(outfile)) {
//       mkdir(pt.dirname(outfile));
//     }

//     if (!isExist(outfile) || readData(infile) != readData(outfile)) {
//       //console.log("copy file:".green,infile,"to".green,outfile)
//       fs.createReadStream(infile, { encoding: "binary" }).pipe(fs.createWriteStream(outfile, { encoding: "binary" }));
//     }

//   }

// }
// // 写文件
// function writeData(path, data, append) {
//   //目录必须存在
//   mkdir(pt.dirname(path));

//   // appendFile，如果文件不存在，会自动创建新文件  
//   // 如果用writeFile，那么会删除旧文件，直接写新文件  
//   if (append) {
//     fs.appendFileSync(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
//   } else {
//     //flag:"a"表示追加
//     fs.writeFileSync(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
//   }

// }

// /*删除已知的文件夹和文件*/
// function remove(paths) {
//   if (!paths) {
//     //console.log("remove:".red,paths,"paths is not valid path".red)
//     return;
//   }
//   paths = toArray(paths)
//   paths.forEach(function(file, index) {
//     if (isExist(file)) {
//       if (isDir(file)) {
//         delDir(file)
//       } else {
//         fs.unlinkSync(file); // 删除文件
//         //console.log("remove:".red,file,"is deleded".red);
//       }
//     }

//   })
// }
// /*删除已知文件名的文件*/
// function delFile(paths) {
//   paths = toArray(paths)
//   paths.forEach(function(file, index) {
//     if (isExist(file) && isFile(file)) {
//       fs.unlinkSync(file); // 删除文件
//       //console.log("delFile:".red,file,"is deleded".red);
//     }
//   })
// }
// /*删除已知文件夹名的文件夹*/
// function delDir(paths) {
//   paths = toArray(paths)
//   paths.forEach(function(file, index) {
//     if (isExist(file) && isDir(file)) {
//       delDirDeep(file);
//     }
//   })
// }

// function delDirDeep(dir) {
//   var paths = getChildrenName(dir);

//   paths.forEach(function(file, index) {
//     var newDir = join(dir, file);
//     if (isFile(newDir)) {
//       fs.unlinkSync(newDir); // 删除文件
//       //console.log("delDirDeep:".red,newDir,"is deleded".red);
//     } else {
//       delDirDeep(newDir);
//     }
//   });
//   fs.rmdirSync(dir); // 删除空文件夹
//   //console.log("delDirDeep:".red,dir,"is deleded".red);
// }

function makeSyncFun(fn){
  fn.replace(/^\s*async\s*[^\{]/)
  console.log(fn.toString())
}
class CachedOutputFileSystem{

  constructor(system){
    this.system= system;
    //添加同步方法
    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(methodName=>{

      if(methodName=="constructor"){
        return;
      }

      this[methodName+"Sync"] =  makeSyncFun( this[methodName] );
    });
  }

  write(file,data,append){
    if(this.system.isFile(file)){
      this.create(file);
    }else{
      console.error("this path is not file!");
    }


    // appendFile，如果文件不存在，会自动创建新文件  
    // 如果用writeFile，那么会删除旧文件，直接写新文件  
    if (append) {
      fs.appendFileSync(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
    } else {
      //flag:"a"表示追加
      fs.writeFileSync(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
    }
  }
  remove(){


  }
  copy(){

  }
  cut(){

  }
  rename(){

  }

  async create(createDirPath,callback){
    if(!createDirPath){
      return;
    }
    if (await this.system.exists(createDirPath)) {
      return;
    }
    //最外层肯定要存在,才可以创建文件
    let parentDirPath =  pt.dirname(dirpath);
    if( !await this.system.exists(parentDirPath) ){
      await this.create(createDirPath);
    }
    
    await fs.mkdir(createDirPath);

    if(typeof callback){
      callback();
    }
  }

}

new CachedOutputFileSystem()