const fs = require("fs");
const pt = require("path");

const makeSyncFunc = require("./makeSyncFunc.js");
// const  makeSyncFun = require("./makeSyncFun.js")
// /*拷贝目录*/
// var copyDir = function(srcDir, workdir, callback) {

//   var files = getFileList(srcDir, true);

//   for (var i = 0; files && i < files.length; i++) {
//     var tempSrc = files[i].replace(srcDir, "")
//     var tempWork = (workdir + "/" + tempSrc).replace(/\/+/g, "/")
//     copyFile(files[i], tempWork)
//   }
// }
// /*拷贝文件*/
// var copyFile = function(infile, outfile) {


//   if (isExist(infile)) {
//     if (!isExist(outfile)) {
//       mkdir(pt.dirname(outfile));
//     }

//     if (!isExist(outfile) || readData(infile) != readData(outfile)) {
//       //console.log("copy file:".green,infile,"to".green,outfile)
//       fs.createReadStream(infile, { encoding: "binary" }).pipe(fs.createWriteStream(outfile, { encoding: "binary" }));
//     }

//   }

// }
// // 写文件
// function writeData(path, data, append) {
//   //目录必须存在
//   mkdir(pt.dirname(path));

//   // appendFile，如果文件不存在，会自动创建新文件  
//   // 如果用writeFile，那么会删除旧文件，直接写新文件  
//   if (append) {
//     fs.appendFileSync(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
//   } else {
//     //flag:"a"表示追加
//     fs.writeFileSync(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
//   }

// }

// /*删除已知的文件夹和文件*/
// function remove(paths) {
//   if (!paths) {
//     //console.log("remove:".red,paths,"paths is not valid path".red)
//     return;
//   }
//   paths = toArray(paths)
//   paths.forEach(function(file, index) {
//     if (isExist(file)) {
//       if (isDir(file)) {
//         delDir(file)
//       } else {
//         fs.unlinkSync(file); // 删除文件
//         //console.log("remove:".red,file,"is deleded".red);
//       }
//     }

//   })
// }
// /*删除已知文件名的文件*/
// function delFile(paths) {
//   paths = toArray(paths)
//   paths.forEach(function(file, index) {
//     if (isExist(file) && isFile(file)) {
//       fs.unlinkSync(file); // 删除文件
//       //console.log("delFile:".red,file,"is deleded".red);
//     }
//   })
// }
// /*删除已知文件夹名的文件夹*/
// function delDir(paths) {
//   paths = toArray(paths)
//   paths.forEach(function(file, index) {
//     if (isExist(file) && isDir(file)) {
//       delDirDeep(file);
//     }
//   })
// }

// function delDirDeep(dir) {
//   var paths = getChildrenName(dir);

//   paths.forEach(function(file, index) {
//     var newDir = join(dir, file);
//     if (isFile(newDir)) {
//       fs.unlinkSync(newDir); // 删除文件
//       //console.log("delDirDeep:".red,newDir,"is deleded".red);
//     } else {
//       delDirDeep(newDir);
//     }
//   });
//   fs.rmdirSync(dir); // 删除空文件夹
//   //console.log("delDirDeep:".red,dir,"is deleded".red);
// }
// /^\W*await(\s*[^\(]+)\(/igm.test("\n!await this.system.exists(parentDirPath")
// !await this.system.exists(parentDirPath


class CachedOutputFileSystem {

  constructor(system) {
    this.system = system;
    //添加同步方法

    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(methodName => {

      if (methodName == "constructor") {
        return;
      }

      this[methodName + "Sync"] = makeSyncFunc(this[methodName]);
    });
  }

  // appendFile，如果文件不存在，会自动创建新文件  
  // 如果用writeFile，那么会删除旧文件，直接写新文件  
  //写数据
  async write(file, data, append) {

    if (!await this.system.exists(file)) {
      await this.create(file);
    }

    if (await this.system.isFile(file)) {
      console.error("this path is not file!");

      if (append) {
        //flag:"a"表示追加
        await fs.appendFile(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
      } else {

        await fs.writeFile(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
      }

      if (typeof callback == "function") {
        callback();
      }
    }

  }

  //刪除
  async remove(src, callback) {
    if (await this.system.exists(src)) {
      if (!this.system.isDir(src)) {
        await fs.unlink(src); // 删除文件
      } else {
        let fileList = await this.system.findFile(src);
        fileList.forEach(file => {
          this.remove(file);
        })
        await fs.rmdir(dir); //删除文件夹
      }

    }
    if (typeof callback == "function") {
      callback();
    }
  }

  //拷貝,overwrite覆盖
  async copy(src, dir, overwrite, callback) {

    if (typeof overwrite == "function") {
      overwrite = false;
      callback = overwrite;
    }

    if (await this.system.exists(src)) {

      if (!await this.system.isDir(src)) {
        //创建父目录
        if (!await this.system.exists(dir)) {
          await this.create(pt.dirname(dir));
        }
        //如果文件存在而且文件内容不相同时覆盖
        if (overwrite && !await this.system.exists(outfile) || await this.system.read(src) != this.system.read(dir)) {
          await new Promise((resolve, reject) => {
            let inputStream = fs.createReadStream(infile, { encoding: "binary" });
            inputStream.pipe(fs.createWriteStream(outfile, { encoding: "binary" }));
            inputStream.on("end", () => {
              resolve();
            });
            inputStream.on("error", () => {
              reject();
            })
          })
        }
      } else {
        let fileList = await this.system.findFile(src, true);
        fileList.forEach(file => {
          let relativePath = pt.relative(src, file);
          await this.copy(file, `${dir}/${relativePath}`, overwrite);
        })
      }

    } else {
      console.warn(`${src} not exists`);
    }

    if (typeof callback == "function") {
      callback();
    }

  }

  //剪切
  async cut(src, dir, callback) {

    if (await this.system.exists(src)) {

      await this.copy(src, dir);

      await this.remove(src);

    } else {
      console.warn(`${src} not exists`);
    }

    if (typeof callback == "function") {
      callback();
    }
  }

  //重命名
  async rename(src, dir, callback) {

    if (await this.system.exists(src)) {

      let path = pt.dirname(src);

      let dirName = pt.basename(dir);

      await fs.rename(src, `${path}/${dirName}`);

    } else {
      console.warn(`${src} not exists`);
    }

    if (typeof callback == "function") {
      callback();
    }

  }
  //創建
  async create(createDirPath, callback) {

    if (!createDirPath) {
      return;
    }

    if (await this.system.exists(createDirPath)) {
      return;
    }

    //最外层肯定要存在,才可以创建文件
    let parentDirPath = pt.dirname(dirpath);

    if (!await this.system.exists(parentDirPath)) {
      await this.create(createDirPath);
    }

    await fs.mkdir(createDirPath);

    if (typeof callback == "function") {
      callback();
    }
  }

}

new CachedOutputFileSystem()