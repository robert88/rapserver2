"use strict";

const Storage = require("./Storage.js");
const fileSystem = require("graceful-fs");
const  AsyncSeries = require("./AsyncSeries.js");
//处理路径
function join(a, b) {
  return (a + "/" + b).replace(/(\/|\\)+/g,"/").replace(/(\/|\\)$/,"");
}


//错误消息
let throwErrorMessage = (err, api, invokeApi, path, errorCollect) => {
  let errMessage = api + "( '" + path + "' )" + invokeApi && (" invoke by " + invokeApi) + ":" + err.message;
  //外部接口
  if (typeof errorCollect == "function") {
    errorCollect(errMessage);
  }
  console.error(errMessage);
}

//检验异步是否完成
function checkFinish(counter, callBack, ret) {
  counter.num--;
  if (counter.num == 0 && typeof callBack == "function") {
    callBack(ret);
  }
}

module.exports = class CachedInputFileSystem {
  constructor(duration) {

    //提供同步和异步api,带缓存,exsits已经废弃
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "");
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "Sync");
    });

    //提供扩展readFile api
    ["readJson", "readData"].forEach(type => {
      let handleCallback = buffer => {
        if (type == "readJson") {
          buffer = JSON.parse(buffer.toString("utf-8"));
        } else {
          buffer = buffer.toString("utf-8");
        }
        return buffer;
      }
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "Sync", handleCallback);
    });

    //提供扩展stat api
    ["getSize", "getModify", "isDir", "isFile", "exists"].forEach(type => {
      let handleCallback = data => {
        switch (type) {
          case "getSize":
            return data.size;
          case "getModify"://精确到s
            return Math.floor(data.mtimeMs/1000)*1000;
          case "isDir":
            return data.isDirectory();
          case "isFile":
            return data.isFile();
            case "exists":
            return typeof data=="object"?true:data;
        }
      }
      CachedInputFileSystem.extendApi.call(this, type, "stat", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "stat", "Sync", handleCallback);
    });

    //提供扩展,依赖readdir isDir exsit 
    ["findFile", "findDir"].forEach(type => {

      let filterFile = (fileType, files) => {
        if (fileType) {
          files = files.filter(function(file) {
            return new RegExp('\\.' + fileType + '$',"i").test(file);
          });
        }

        /*del mac pc has .DS_Store file*/
        files = files.filter(function(file) {
          return file.indexOf(".DS_Store") == -1
        });

        return files;
      }

      if (!this[type]) {
        this[type] = (path, fileType, deep, callback) => {
          if(typeof fileType=="function"){
            callback = fileType;
            fileType = "";
            deep = false;
          }else if(typeof deep=="function"){
            callback = deep;
            deep = false;
          }
          if(typeof fileType=="boolean"){
            deep = fileType;
            fileType = "";
          }
          this.wake(path, deep,type=="findFile"?true:false, data => {
            let ret = type=="findFile"?filterFile(fileType, data):data;
            callback(ret);
          });
        }
      }

      if (!this[type + "Sync"]) {
        this[type + "Sync"] = (path, fileType, deep) => {
          if(typeof fileType=="boolean"){
            deep = fileType;
            fileType = "";
          }
          let data = this.wakeSync(path, deep, type=="findFile"?true:false);
          return  type=="findFile"?filterFile(fileType, data):data;
        }
      }
    });


  }

  //绑定到cache
  static fileSystemBindCache(type, duration, syncFlag) {


    duration = duration || 6000;

    let storageId = "_" + type + "Storage";

    //同步和异步提供一个storage
    if (!this[storageId]) {
      this[storageId] = new Storage(duration);
    }

    let api = type + syncFlag;

    //=> this.readdir => storage => fileSystem.readdir => graceful-fs.readdir = nodejs fs.readdir
    if (fileSystem[api] && !this[api]) {
      this[api] = (path, success, error) => {
        //异步返回是空，同步callback无效
        try {
          return this[storageId]["provide" + syncFlag](path, fileSystem[api].bind(fileSystem), function(err, data) {
            if (err) {
              throwErrorMessage(err, api, storageId, path, error);
              return;
            }
            if (typeof success == "function") {
              success(data);
            }
          });
        } catch (err) {
          throwErrorMessage(err, api, null, storageId, error);
        }

      }
    }

  }



  //扩展简单接口
  static extendApi(type, invokeType, syncFlag, handleCallback) {

    let invokeApi = invokeType + syncFlag;
    let api = type + syncFlag;

    if (this[invokeApi] && !this[api]) {
      this[api] = (path, success, error) => {

        let ret;
        if (syncFlag == "Sync") {

          let buffer = this[invokeApi](path, success, error);

          //JSON.parse的错误使用try
          try {
            ret = handleCallback(buffer);
          } catch (err) {
            throwErrorMessage(err, api, invokeApi, path, error);
          }

          return ret;

        } else {
          this[invokeApi](path, (buffer) => {

            if (typeof success == "function") {
              //JSON.parse的错误使用try
              try {
                buffer = handleCallback(buffer);
              } catch (err) {
                throwErrorMessage(err, api, invokeApi, path, error);
              }
              //扩展的api不需要处理err
              success(buffer);
            }
          },error);
        }

      }
    }
  }


  //返回值可以得到ret，也可以传递ret
  wake(dir, deep, findFile,  callback,ret, counter) {

    ret = ret || [];
    counter = counter || { num: 0 };
    counter.num++;
    new AsyncSeries([
      this.exists,
      this.isDir,
      this.readdir
    ],(fn,i,series)=>{
      fn.call(this,dir,data=>{
        //如果不存在就返回
        if(i<2&&!data){
          series.done(data);
        }
        series.loop(data);
      },(err)=>{
        series.done(err)
      });

    },(files)=>{

        files&&files.forEach((fileName) => {
            //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
            var newDir = join(dir, fileName);

            counter.num++;

            this.isDir(newDir, isDirFlag => {
              //添加文件
              if (findFile && !isDirFlag) {
                ret.push(newDir);
                //添加文件夹
              } else if (!findFile && isDirFlag) {
                ret.push(newDir);
              }
              //深度遍历
              if (deep&&isDirFlag) {
                this.wake(newDir, deep, findFile, callback,  ret, counter);
              }
              checkFinish(counter, callback, ret);
            }, () => {
              checkFinish(counter, callback, ret);
            })
          });
        
      checkFinish(counter, callback, ret);

    })
   
    return ret;
  }

  wakeSync(dir, deep, findFile, ret) {
    ret = ret || [];
    if (this.existsSync(dir)) {
      if (this.isDirSync(dir)) {

        let files = this.readdirSync(dir);

        files&&files.forEach((fileName) => {
          //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
          var newDir = join(dir, fileName);

          let isDirFlag = this.isDirSync(newDir);

          //添加文件
          if (findFile && !isDirFlag) {
            ret.push(newDir);
            //添加文件夹
          } else if (!findFile && isDirFlag) {
            ret.push(newDir);
          }

          //深度遍历
          if (deep&&isDirFlag) {
            this.wakeSync(newDir, deep, findFile, ret)
          }

        });

      }
    }
    return ret;
  }

  //清除缓存
  purge(what) {
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      this["_" + type + "Storage"].purge(what);
    })
  }

  //获取文件系统api
  getSystem(){
    return fileSystem;
  }
};