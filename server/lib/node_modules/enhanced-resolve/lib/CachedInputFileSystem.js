/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const Storage = require("./Storage.js");

function join(a,b){
	return (a+"/"+b).replace(/\/+/g,"/")
}

module.exports = class CachedInputFileSystem {
	constructor(fileSystem, duration) {
		this.fileSystem = fileSystem;
		
		//提供同步和异步api
		["readdir","stat","readfile","readlink","exists"].forEach(type=>{
			CachedInputFileSystem.fileSystemBindCache.call(this,type,duration);
		});

		//提供扩展readFile api
		["readJson","readData"].forEach(type=>{
			CachedInputFileSystem.extendApi.call(this,type,"readFile",data=>{
				if(type=="readJson"){
					data = JSON.parse(buffer.toString("utf-8"));
				}else{
					data = buffer.toString("utf-8");
				}
				return data;
			});
		});

		//提供扩展readdir api
		["findFile","findDir"].forEach(type=>{
			CachedInputFileSystem.extendDeepApi.call(this,
				type,
				"readdir",
				//异步接口
				async (path,deep,fileType)=>{
					// if(! await this.exists(path)){
					// 	return [];
					// }
					// if(typeof fileType=="boolean"){
					// 	deep = fileType;
					// 	fileType = null;
					// }
					// let files = [];
					// switch (type) {
					// 	case "findFile":
					// 		await this.wake(path,files,deep,true);
					// 	break;
					// 	case "findDir":
					// 		await this.wake(path,files,deep,false);
					// 	default:
					// 		break;
					// }

					// if(fileType) {
					// 	files = files.filter(function(file) {
					// 		return new RegExp('\\.' + type + '$').test(file);
					// 	});
					// }
			
					// /*del mac pc has .DS_Store file*/
					// files = files.filter(function(file) {
					// 	return file.indexOf(".DS_Store")==-1
					// });

					// return files;
				},
				//同步接口
				(path,deep,fileType)=>{
					if(!this.existsSync(path)){
						return [];
					}
					if(typeof fileType=="boolean"){
						deep = fileType;
						fileType = null;
					}
					let files = [];
					switch (type) {
						case "findFile":
							this.wakeSync(path,files,deep,true);
						break;
						case "findDir":
							this.wakeSync(path,files,deep,false);
						default:
							break;
					}

					if(fileType) {
						files = files.filter(function(file) {
							return new RegExp('\\.' + type + '$').test(file);
						});
					}
			
					/*del mac pc has .DS_Store file*/
					files = files.filter(function(file) {
						return file.indexOf(".DS_Store")==-1
					});

					return files;
				}
			);
		});



		
		//提供扩展stat api
		["getSize","getModify","isDir","isFile"].forEach(type=>{
			CachedInputFileSystem.extendApi.call(this,type,"stat",data=>{
				switch (type) {
					case "getSize":
						return data.size;
					case "getModify":
						return data.mtimeMs;
					case "isDir":
						return data.isDirectory();
					case "isFile":
						return data.isFile();
					default:
						break;
				}

				return data;
			});
		})
	}

	//绑定到cache
	static fileSystemBindCache(type,duration){

		this["_"+type+"Storage"] = new Storage(duration);
		
		//添加异步
		this["_"+type] = this.fileSystem[type] ? this.fileSystem[type].bind(this.fileSystem) : null;

		//添加同步
		this["_"+type+"Sync"] = this.fileSystem[type+"Sync"] ? this.fileSystem[type+"Sync"].bind(this.fileSystem) : null;

		CachedInputFileSystem.extendApi.call(this,type);
	}

	//扩展深度调用
	static extendDeepApi(type,api,handle,syncHandle){
		//添加异步api
		if(this.fileSystem[type]) {
			this["_"+type] = this.fileSystem[type].bind(this.fileSystem);
		} else if(this[api]) {
			this["_"+type] = handle
		}


		//添加同步api
		if(this.fileSystem[type+"Sync"]) {
			this["_"+type+"Sync"] = this.fileSystem[type+"Sync"].bind(this.fileSystem);
		} else if(this[api+"Sync"]) {
			this["_"+type+"Sync"] = syncHandle
		}

		CachedInputFileSystem.exportApi.call(this,type);
	}

	//扩展简单接口
	static extendApi(type,api,handle){
		
		CachedInputFileSystem.extendDeepApi.call(this,
			type,
			api,
			//异步接口
			(path, callback) => {
				this[api](path, (err, buffer) => {
					if(err) return callback(err);
					let data;
					try {
						data = handle(data);
					} catch(e) {
						return callback(e);
					}
					callback(null, data);
				});
			},
			// 同步接口
			(path) => {
				const buffer = this[api+"Sync"](path);
				let data;
				try {
					data = handle(data);
				} catch(e) {
					console.log(e);
					return null;
				}
				return data;
			}
			);

	}


	//输出接口
	static exportApi(type){

		//添加异步api
		if(	this["_"+type] ){
			this[type] = (path,callback)=>{
				this["_"+type+"Storage"].provide(path,this["_"+type], callback);
			}
		} 

		//添加同步api
		if(["_"+type+"Sync"] ){
			this[type+"Sync"] = (path)=>{
				return this["_"+type+"Storage"].provideSync(path,this["_"+type+"Sync"]);
			}
		} 

	}

	async wake(dir, ret,deep, wakeFile) {
		// if(await this.exists(dir)) {
		// 	if(await this.isDir(dir)) {
				
		// 		let files = await this.readdir(dir);

		// 		files.forEach(function(fileName,idx){
		// 			//直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
		// 			var newDir = join(dir, fileName);
		// 			//深度遍历
		// 			if(deep){
		// 				await this.wake(newDir ,ret,deep, wakeFile);
		// 			}

		// 			//添加文件
		// 			if(wakeFile&&!(await this.isDir(newDir)) ){
		// 				ret.push(newDir);
		// 			//添加文件夹
		// 			}else if(!wakeFile&& (await this.isDir(newDir)) ){
		// 				ret.push(newDir);
		// 			}
		// 		});
				
		// 	}
		// }
		// return ret;
	}

	wakeSync(dir, ret,deep, wakeFile) {
		if(this.existsSync(dir)) {
			if(this.isDirSync(dir)) {

				let files = this.readdirSync(dir);

				files.forEach(function(fileName){
					//直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
					var newDir = join(dir, fileName);
					//深度遍历
					if(deep){
						this.wakeSync(newDir, ret,deep, wakeFile);
					}

					//添加文件
					if(wakeFile&&!this.isDirSync(newDir)){
						ret.push(newDir);
					//添加文件夹
					}else if(!wakeFile&& this.isDirSync(newDir)){
						ret.push(newDir);
					}
				});
				
			}
		}
		return ret;
	}

	//清除缓存
	purge(what) {
		["readdir","stat","readFile","readlink","exists"].forEach(type=>{
			this["_"+type+"Storage"].purge(what);
		})
	}
};
