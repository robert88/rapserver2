"use strict";

const Storage = require("./Storage.js");

//处理路径
function join(a, b) {
  return (a + "/" + b).replace(/\/+/g, "/")
}

//错误消息
let throwErrorMessage = (err, api, invokeApi, path, errorCollect) => {
  let errMessage = api + "( '" + path + "' )" + invokeApi && (" invoke by " + invokeApi) + ":" + err.message;
  //外部接口
  if (typeof errorCollect == "function") {
    errorCollect(errMessage);
  }
  console.error(errMessage);
}
//检验异步是否完成
function checkFinish(counter, callBack, ret) {
  counter.num--;
  if (counter.num == 0 && typeof callBack == "function") {
    callBack(ret);
  }
}

module.exports = class CachedInputFileSystem {
  constructor(fileSystem, duration) {
    this.fileSystem = fileSystem;

    //提供同步和异步api,带缓存
    ["readdir", "stat", "readFile", "readlink", "exists"].forEach(type => {
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "");
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "Sync");
    });

    //提供扩展readFile api
    ["readJson", "readData"].forEach(type => {
      let handleCallback = buffer => {
        if (type == "readJson") {
          buffer = JSON.parse(buffer.toString("utf-8"));
        } else {
          buffer = buffer.toString("utf-8");
        }
        return buffer;
      }
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "Sync", handleCallback);
    });

    //提供扩展stat api
    ["getSize", "getModify", "isDir", "isFile"].forEach(type => {
      let handleCallback = data => {
        switch (type) {
          case "getSize":
            return data.size;
          case "getModify":
            return data.mtimeMs;
          case "isDir":
            return data.isDirectory();
          case "isFile":
            return data.isFile();
        }
      }
      CachedInputFileSystem.extendApi.call(this, type, "stat", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "stat", "Sync", handleCallback);
    });

    //提供扩展,依赖readdir isDir exsit 
    ["findFile", "findDir"].forEach(type => {

      let filterFile = (fileType, files) => {
        if (fileType) {
          files = files.filter(function(file) {
            return new RegExp('\\.' + type + '$').test(file);
          });
        }

        /*del mac pc has .DS_Store file*/
        files = files.filter(function(file) {
          return file.indexOf(".DS_Store") == -1
        });

        return files;
      }

      if (!this[type]) {
        this[type] = (path, fileType, deep, callback) => {
          this.wake(path, fileType, deep, data => {
            let ret = filterFile(fileType, data);
            callback(ret);
          });
        }
      }

      if (!this[type + "Sync"]) {
        this[type + "Sync"] = (path, fileType, deep) => {
          let data = this.wakeSync(path, fileType, deep);
          return filterFile(fileType, data);
        }
      }
    });


  }

  //绑定到cache
  static fileSystemBindCache(type, duration, syncFlag) {


    duration = duration || 6000;

    let storageId = "_" + type + "Storage";

    //同步和异步提供一个storage
    if (!this[storageId]) {
      this[storageId] = new Storage(duration);
    }

    let api = type + syncFlag;

    //=> this.readdir => storage => this.fileSystem.readdir => graceful-fs.readdir = nodejs fs.readdir
    if (this.fileSystem[api] && !this[api]) {
      this[api] = (path, success, error) => {
        //异步返回是空，同步callback无效
        try {
          return this[storageId]["provide" + syncFlag](path, this.fileSystem[api].bind(this.fileSystem), function(err, data) {
            if (err) {
              throwErrorMessage(err, api, storageId, path, error);
              return;
            }
            if (typeof success == "function") {
              success(data);
            }
          });
        } catch (err) {
          throwErrorMessage(err, api, null, storageId, error);
        }

      }
    }

  }



  //扩展简单接口
  static extendApi(type, invokeType, syncFlag, handleCallback) {

    let invokeApi = invokeType + syncFlag;
    let api = type + syncFlag;

    if (this[invokeApi] && !this[api]) {
      this[api] = (path, success, error) => {

        let ret;
        if (syncFlag == "Sync") {
          try {
            let buffer = this[invokeApi](path, success, error);
            ret = handleCallback(buffer);
            return ret;
          } catch (err) {
            //同步和JSON.parse的错误
            throwErrorMessage(err, api, invokeApi, path, error);
          }
        } else {
          this[invokeApi](path, (e, buffer) => {
            if (e) {
              //异步的错误
              throwErrorMessage(e, api, invokeApi, path, error);
              return;
            }
            if (typeof success == "function") {
              try {
                buffer = handleCallback(buffer);
              } catch (err) {
                //JSON.parse的错误
                throwErrorMessage(err, api, invokeApi, path, error);
              }
              //扩展的api不需要处理err
              success(buffer);
            }
          });
        }

      }
    }
  }


  //返回值可以得到ret，也可以传递ret
  wake(dir, deep, findFile, ret, callback, counter) {
    ret = ret || [];
    counter = counter || { num: 0 };
    counter.num++;
    this.exists(dir, (flag) => {

      flag && this.isDir(dir, (isDirFlag) => {

        isDirFlag && this.readdir(dir, (files) => {
          files.forEach((fileName) => {
            //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
            var newDir = join(dir, fileName);

            counter.num++;

            this.isDir(newDir, isDirFlag => {
              //添加文件
              if (findFile && !isDirFlag) {
                ret.push(newDir);
                //添加文件夹
              } else if (!findFile && isDirFlag) {
                ret.push(newDir);
              }
              //深度遍历
              if (deep) {
                this.wake(dir, deep, findFile, ret, callback, counter);
              }
              checkFinish(counter, callback, ret);
            }, () => {
              checkFinish(counter, callback, ret);
            })
          });

          checkFinish(counter, callback, ret);

        }, (err) => {
          checkFinish(counter, callback, ret);
        });
      }, (err) => {
        checkFinish(counter, callback, ret);
      });
    }, (err) => {
      checkFinish(counter, callback, ret);
    })

    return ret;
  }

  wakeSync(dir, deep, findFile, ret) {
    ret = ret || [];
    if (this.existsSync(dir)) {
      if (this.isDirSync(dir)) {

        let files = this.readdirSync(dir);

        files.forEach((fileName) => {
          //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
          var newDir = join(dir, fileName);

          let isDirFlag = this.isDirSync(newDir);

          //添加文件
          if (findFile && !isDirFlag) {
            ret.push(newDir);
            //添加文件夹
          } else if (!findFile && isDirFlag) {
            ret.push(newDir);
          }

          //深度遍历
          if (deep) {
            this.wakeSync(dir, deep, findFile, ret)
          }

        });

      }
    }
    return ret;
  }

  //清除缓存
  purge(what) {
    ["readdir", "stat", "readFile", "readlink", "exists"].forEach(type => {
      this["_" + type + "Storage"].purge(what);
    })
  }
};