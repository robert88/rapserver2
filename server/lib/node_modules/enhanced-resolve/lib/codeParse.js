"use strict";

const toReg = require("enhanced-resolve/lib/toReg");

//获取code和arg的字符串
//每一个await必须单独占一行
function getArgAndCode(fn) {
  if (typeof fn !== "function") {
    throw "getArgAndCode params must function type!";
  }
  var str = fn.toString();
  let code = "";
  let arg = "";
  let name = "";
  let asyncType = false;

  var objectFunctionReg = /^\s*(async)?\s*function\s*([$_0-9a-zA-Z]+\s*)?\(([^\)]*)\)\s*\{([\u0000-\uFFFF]*)\}$/igm;
  var objectArrowReg = /^\s*(async)?(\s*)\(([^\)]*)\)\s*=>\s*\{([\u0000-\uFFFF]*)\}$/igm;
  var classMethod = /^\s*(async)?\s*([$_0-9a-zA-Z]+\s*)?\(([^\)]*)\)\s*\{([\u0000-\uFFFF]*)\}$/igm;
  var normal = /^\s*(async)?(\s*)([^\{]*)\{([\u0000-\uFFFF]*)\}$/igm;
  var matchReg;
  if (objectFunctionReg.test(str)) {
    // async function({b}){}

    objectFunctionReg.lastIndex = 0;
    matchReg = objectFunctionReg;

  } else if (objectArrowReg.test(str)) {
    // async ({b,a})=>{}
    // async (a,b)=>{}
    objectArrowReg.lastIndex = 0;
    matchReg = objectArrowReg;
  } else if (classMethod.test(str)) {
    //async write(){}
    classMethod.lastIndex = 0;
    matchReg = classMethod;
  } else {
    // async a=>{}
    matchReg = normal;
  }

  str.replace(matchReg, function(m, m1, m2, m3, m4) {
    asyncType = m1 ? true : false;
    name = m2&&m2.replace(/\s+/g, "");
    arg = m3&&m3.replace(/=>/g, "").replace(/\s+/g, " ");
    code = m4;
  });

  return [code, arg, name, asyncType];
}

function replaceObject(argStr) {
  argStr = argStr.replace(/\{[^\}]*\}/g, "a").replace(/\[[^\]]*\]/g, "a");
  if (/\{[^\}]*\}/.test(argStr) || /\[[^\]]*\]/g.test(argStr)) {
    return replaceObject(argStr)
  }
  return argStr;
}
//获取arg的长度
function getArgLen(argStr) {
  argStr = replaceObject(argStr);
  return argStr.split(",").length;
}


//格式化代码
function formatSpace(code) {

  var codes = code.split(/(\n|\r)+/);
  var newCodes = [];
  codes.forEach(d => {

    d = d.replace(/^\s+|\s+$/g, "")
    if (d) {
      newCodes.push(d);
    }
  })
  code = newCodes.join("\n");
  return code;
}

//成对出现排除
function filterByClose(filterArr, key, pervKey, matchdKey) {
  let matchd = false;
  //将字符串排除
  filterArr.forEach(f => {
    if (f == key) {
      matchd = true;
      return false;
    }
  })

  if (matchd && pervKey != "\\") {
    if (key == matchdKey) {
      matchdKey = ""
    } else {
      matchdKey = key;
    }
  }

  return matchdKey;

}

//有嵌套闭合
function filterByTreeClose(per, next, key, count) {

  let matchdPerv = false;
  per.forEach(f => {
    if (f == key) {
      matchdPerv = true;
      return false;
    }
  })

  let matchdnext = false;
  next.forEach(f => {
    if (f == key) {
      matchdnext = true;
      return false;
    }
  })

  //保持count始终是个数字

  count = count || 0;
  //匹配到表达式
  if (matchdPerv) {
    count++;
  }

  if (count) {
    if (matchdnext) {
      count--;
    }
    return count;
  }
}

//提取变量
function findRightOffsetByStatement(m1,ret,code) {
   ret = ret || [];
   code = code || [];
  var reg = /[=%:&,!><\|\+\-\~\^\*\/\?]/
  let len = m1.length;
  let matchdKey;
  let expressionOffset = 0;
  let arrayOffset = 0;
  let equeOffset = 0;
  let i = 0;
  let stateStr = "";
  //从前面开始找
  while (i < len) {
    let key = m1[i++];
    let pervKey = m1[i - 2];
    let skip = 0;

    if (matchdKey = filterByClose(["'", '"'], key, pervKey, matchdKey)) {
      code.push(key);
      continue;
    }

    if ((equeOffset = filterByTreeClose(["{"], ["}"], key, equeOffset)) != null) {
      code.push(key);
      continue;
    }

    if ((arrayOffset = filterByTreeClose(["["], ["]"], key, arrayOffset)) != null) {
          code.push(key);
      continue;
    }

    if(/function\s/.test(m1.slice(i-1,9))){
      stateStr="function"
      skip = 9;
    }
    if(/var\s/.test(m1.slice(i-1,4))){
      stateStr="var"
      skip = 4;
    }
    if(/let\s/.test(m1.slice(i-1,4))){
      stateStr="let"
      skip = 4;
    }
    if(/const\s/.test(m1.slice(i-1,6))){
      stateStr="const"
      skip = 6;
    }
    if(/bclass\s/.test(m1.slice(i-1,6))){
      stateStr="class"
      skip = 6;
    }
    if(skip){
      ret.push(stateStr+" ");
      i=i+skip-1;
      continue;
    }

    code.push(key);

    if(!stateStr){
      continue;
    }


    //匹配到结束语句
    if (key == ";" || (key == "\n" && !reg.test(pervKey)) ) {

      if(ret.length&&ret[ret.length-1]!=";"){
        ret.push(";")
      }
    
      return  findRightOffsetByStatement(m1.slice(i,m1.length),ret,code)
    }

    reg.lastIndex = 0;

    if ((expressionOffset = filterByTreeClose(["="], [","], key, expressionOffset)) != null) {
      if(key==","){
        expressionOffset=0
        ret.push(",")
      }
      continue;
    }

    ret.push(key);
  }

  if(ret.length&&ret[ret.length-1]!=";"){
    ret.push(";")
  }

  return {state:ret.join(""),code:code.join("")};
}
//判断左边是否关联一个语句
function findLeftOffsetByExpression(m1,expression) {
  expression = expression ||[];
  let len = m1.length;
  var reg = /[=%:&,!><\|\+\-\~\^\*\/\?]/
  let matchdKey;
  let equeOffset = 0;

  //从后面开始找
  while (len--) {
    let key = m1[len];
    let pervKey = m1[len - 1];
    //将字符串排除
    if (matchdKey = filterByClose(["'", '"'], key, pervKey, matchdKey)) {
      continue;
    }

    if ((equeOffset = filterByTreeClose(["}"], ["{"], key, equeOffset)) != null) {
      continue;
    }

    //匹配到结束语句
    if (key == "{" || key == ";" || (key == "\n" && !reg.test(pervKey))) {
      return len;
    }
    //还原匹配
    reg.lastIndex = 0;
  }
  return  -1;
}



//去掉注释
function removeNote(code) {
  //双引号
  code = code.replace(/\\"/gm, "#makeSyncFunc_quote#").replace(/"[^"]+"/g, function(m) {
      return m
        .replace(/\/\*/g, "#make_note_mutil_line#")
        .replace(/(\/\/)+/g, "#make_note_line#")
    })
    .replace(/#makeSyncFunc_quote#/gm, '\\"');
  //单引号
  code = code.replace(/\\'/gm, "#makeSyncFunc_quote#").replace(/'[^']+'/g, function(m) {
      return m
        .replace(/\/\*/g, "#make_note_mutil_line#")
        .replace(/(\/\/)+/g, "#make_note_line#")
    })
    .replace(/#makeSyncFunc_quote#/gm, "\\'");

  var noteReg = /\/\*[\u0000-\uFFFF]*?\*\//gm;
  var noteReg2 = /\/\/[^\n]*/gm;

  return code.replace(noteReg, "").replace(noteReg2, "").replace(/#make_note_line#/g, "//").replace(/#make_note_mutil_line#/g, "/*");
}
//根据线索
function findLeftOffsetByString(code, needFindLetter, notFindLetter) {
  needFindLetter = needFindLetter || "}";
  notFindLetter = notFindLetter || "{";
  let len = code.length;
  let offset = 0;
  let i = 0;
  let matchdKey='';
  while (i < len) {
    let key = code[i++];
    let pervKey = code[i - 2];
    if (matchdKey = filterByClose(["'", '"'], key, pervKey, matchdKey)) {
      continue;
    }
    if (key == notFindLetter) {
      offset++;
      continue;
    }
    if (offset > 0 && key == needFindLetter) {
      offset--;
      continue;
    }
    if (key == needFindLetter) {
      return i - 1;
    }

  }
  return len;
}
//匹配&& 和 ||
function matchAndOrExcepssion(code){
  

  let needQ = false;
  let ret = [];
  let len = code.length;
  var reg = /[=%:&,!><\|\+\-\~\^\*\/\?]/
  let matchdKey;
  let equeOffset = 0;
  let qOffset = 0;
  //没有&&，||
  if(!/(&{2})|(\|{2})/.test(code) ){
    return {needQ:needQ,code:ret.join("")}
   }
  //从后面开始找
  while (len--) {
    let key = code[len];
    let pervKey = code[len - 1];
    //将字符串排除
    if (matchdKey = filterByClose(["'", '"'], key, pervKey, matchdKey)) {
      ret.unshift(key);
      continue;
    }

    if ((equeOffset = filterByTreeClose(["}"], ["{"], key, equeOffset)) != null) {
      ret.unshift(key);
      continue;
    }

    if ((qOffset = filterByTreeClose([")"], ["("], key, qOffset)) != null) {
      ret.unshift(key);
      continue;
    }
    //需要闭合
    if(key == "("){
      needQ = true;
    }

    //匹配到结束语句
    if (key == ","||key == "{" || key == ";" || (key == "\n" && !reg.test(pervKey))) {
      return {needQ:needQ,code:ret.join("")}
    }
    //还原匹配
    ret.unshift(key);
    reg.lastIndex = 0;
  }
   return {needQ:needQ,code:ret.join("")}

}
module.exports = {
  getArgAndCode,
  getArgLen,
  formatSpace,
  removeNote,
  findLeftOffsetByExpression,
  findRightOffsetByStatement,
  matchAndOrExcepssion,
  findLeftOffsetByString
}

