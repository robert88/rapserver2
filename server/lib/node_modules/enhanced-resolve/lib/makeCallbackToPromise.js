"use strict";

const { getArgAndCode, getArgLen } = require("./codeParse.js")

//将带有同步和异步接口的转换
let makeCallbackToPromise = function(input, except,context) {
  var syncFunc = [];
  if (typeof input == "object") {
    var keys = Object.keys(input);
    keys.forEach((key) => {
      if (/(.*)Sync$/.test(key)) {
        //排除
        key = RegExp["$1"];
        if (except && ~except.indexOf(key)) {
          return;
        }
        if (typeof input[key] == "function") {
          syncFunc.push(key);
        }
      }
    })
  } else if (typeof input == "function") {
    let fun = input;
    var strInfo = getArgAndCode(fun);
    syncFunc.push(strInfo[2]||"a");
    input = { };
    input[syncFunc[0]] = fun;
  }

  syncFunc.forEach((key) => {

    let inner = input[key];

    var strInfo = getArgAndCode(inner);

    let argsLeng = getArgLen(strInfo[1]);


    input[key] = function(...args) {
      return new Promise((resove, reject) => {
        //实参中带有callback必须执行一次
        let argCallback
        if (argsLeng != 0) {
          argCallback = args[argsLeng - 1]
        }

        let callback = function(err, ret) {

          if (err) {
            reject(err);
          } else {
            resove(ret);
          }
          //在当前状态改变之后执行后面的callback
          if (typeof argCallback == "function") {
            argCallback(err, ret);
          }
        }
        //如何保证args和定义的args对于
        //形参没有定义，callback一定位于最后一为
        if (argsLeng == 0) {
          args.push(callback);
        } else {
          //形参和实参一致，那么callback为args的索引值是固定的
          args[argsLeng - 1] = callback;
        }
        inner.apply(context||input, args);
      })
    }
  })

  return input;
}

module.exports = makeCallbackToPromise;