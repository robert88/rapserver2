"use strict";

const { getArgAndCode, getArgLen } = require("./codeParse.js")

//将带有同步和异步接口的转换
module.exports = function(input, except) {
  if (typeof input != "object") {
    return;
  }
  var keys = Object.keys(input);
  var syncFunc = [];
  keys.forEach((key) => {
    if (/Sync$/.test(key)) {
      syncFunc.push(key);
    }
  })
  syncFunc.forEach((key) => {

    var asyncFunc = key.replace(/Sync$/, "");
    //排除
    if (except && ~except.indexOf(asyncFunc)) {
      return;
    }
    var inner = input[asyncFunc];

    var strInfo = getArgAndCode(inner);

    let argsLeng = getArgLen(strInfo[1]);

    //考虑到有{},[]

    if (inner) {
      input[asyncFunc] = function(...args) {
        return new Promise((resove, reject) => {
          //实参中带有callback必须执行一次
          let argCallback
          if (argsLeng != 0) {
            argCallback = args[argsLeng - 1]
          }

          let callback = function(err, ret) {
        
              if(err){
               reject(err);
              }else{
                resove(ret);
              }
              //在当前状态改变之后执行后面的callback
              if (typeof argCallback == "function") {
                argCallback(err, ret);
              }
          }
          //如何保证args和定义的args对于
          //形参没有定义，callback一定位于最后一为
          if (argsLeng == 0) {
            args.push(callback);
          } else {
            //形参和实参一致，那么callback为args的索引值是固定的
            args[argsLeng - 1] = callback;
          }
          inner.apply(input, args);
        })
      }
    }
  })
  return input;
}