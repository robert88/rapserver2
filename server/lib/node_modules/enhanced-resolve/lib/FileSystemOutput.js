const fs = require("fs");
const pt = require("path");

const makeSyncFunc = require("./makeSyncFunc");
const makeCallbackFunc = require("./makeCallbackFunc");
const FileSystemInput = require("./FileSystemInput");
const makeCallbackToPromise = require("./makeCallbackToPromise");

class ConverOutPut{
  constructor(need) {
    ["mkdir","rename","appendFile","writeFile","unlink","rmdir","createReadStream","createWriteStream"].forEach(api=>{
      this[api]= fs[api];
      this[api+"Sync"]= fs[api+"Sync"];
    })
    if(need){
      Object.assign(this,makeCallbackToPromise(this));
    }
  }
}

class FileSystemOutput {
  //debug 开启async语法
  constructor(system,debug) {
    var inputfilesystem = new FileSystemInput(5000);
    if(debug){
      this.system = system || Object.assign(new ConverOutPut(true),makeCallbackToPromise(inputfilesystem,["wake"]),{purge:inputfilesystem.purge});
    }else{
      this.system = system || Object.assign(new ConverOutPut(),inputfilesystem,{purge:inputfilesystem.purge});
    }
   
    //添加同步方法

    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(methodName => {

      if (methodName == "constructor") {
        return;
      }

      this[methodName + "Sync"] = makeSyncFunc(this[methodName]);
      
      if(!debug){
        this[methodName] = makeCallbackFunc(this[methodName]);
      }

    });
  }

  // appendFile，如果文件不存在，会自动创建新文件  
  // 如果用writeFile，那么会删除旧文件，直接写新文件  
  //写数据
  async write(file, data, append) {

    await this.create(file,true);

    if (await this.system.isFile(file)) {
      console.error("this path is not file!");

      if (append) {
        //flag:"a"表示追加
        await fs.appendFile(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
      } else {

        await fs.writeFile(path, data, { encoding: 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
      }

      if (typeof callback == "function") {
        callback();
      }
    }

  }

  //刪除
  async remove(src, callback) {
    if (await this.system.exists(src)) {
      if (!this.system.isDir(src)) {
        await fs.unlink(src); // 删除文件
      } else {
        let fileList = await this.system.findFile(src);
        fileList.forEach(file => {
          this.remove(file);
        })
        await fs.rmdir(dir); //删除文件夹
      }

    }
    if (typeof callback == "function") {
      callback();
    }
  }

  //拷貝,overwrite覆盖
  async copy(src, dir, overwrite, callback) {

    if (typeof overwrite == "function") {
      overwrite = false;
      callback = overwrite;
    }

    if (await this.system.exists(src)) {

      if (!await this.system.isDir(src)) {
        //创建父目录
        if (!await this.system.exists(dir)) {
          await this.create(pt.dirname(dir));
        }
        //如果文件存在而且文件内容不相同时覆盖
        if (overwrite && !await this.system.exists(outfile) || await this.system.read(src) != this.system.read(dir)) {
          await new Promise((resolve, reject) => {
            let inputStream = fs.createReadStream(infile, { encoding: "binary" });
            inputStream.pipe(fs.createWriteStream(outfile, { encoding: "binary" }));
            inputStream.on("end", () => {
              resolve();
            });
            inputStream.on("error", () => {
              reject();
            })
          })
        }
      } else {
        let fileList = await this.system.findFile(src, true);
        let len = fileList||fileList.length||0
        while(len--){
          await this.copy(fileList[len], `${dir}/${relativePath}`, overwrite);
        }
      }

    } else {
      console.warn(`${src} not exists`);
    }

    if (typeof callback == "function") {
      callback();
    }

  }

  //剪切
  async cut(src, dir, callback) {

    if (await this.system.exists(src)) {

      await this.copy(src, dir);

      await this.remove(src);

    } else {
      console.warn(`${src} not exists`);
    }

    if (typeof callback == "function") {
      callback();
    }
  }

  //重命名
  async rename(src, dir, callback) {

    if (await this.system.exists(src)) {

      let path = pt.dirname(src);

      let dirName = pt.basename(dir);

      await fs.rename(src, `${path}/${dirName}`);

    } else {
      console.warn(`${src} not exists`);
    }

    if (typeof callback == "function") {
      callback();
    }

  }
  //必须指定是创建文件还是创建目录
  async create(createDirPath,isFile,callback) {

    if (!createDirPath) {
      return;
    }

    if (await this.system.exists(createDirPath)) {
      return;
    }

    //最外层肯定要存在,才可以创建文件
    let parentDirPath = pt.dirname(createDirPath);

    if (parentDirPath && !await this.system.exists(parentDirPath)) {
      await this.create(parentDirPath,false);
    }

    // if(isFile){
    //   // await this.system.writeFile(createDirPath,"");
    // }else{

    // }
    await this.system.mkdir(createDirPath);

    this.system.purge("stat",createDirPath);

    if (typeof callback == "function") {
      callback();
    }
  }

}
var demoPath = "C:\\Users\\ywx533137\\Desktop\\topic";

// async function test(){
// var a = await inputfilesystem.exists("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt")
// }
// test();
var inpt = new FileSystemOutput(null,true);
inpt.write("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt","this a");
