const fs = require("fs");
const pt = require("path");

const makeSyncFunc = require("./makeSyncFunc");
const makeCallbackFunc = require("./makeCallbackFunc");
const FileSystemInput = require("./FileSystemInput");
const makeCallbackToPromise = require("./makeCallbackToPromise");

class ConverOutPut {
  constructor(debug) {
    ["mkdir", "rename", "appendFile", "writeFile", "unlink", "rmdir", "copyFile"].forEach(api => {
      this[api] = fs[api];
      this[api + "Sync"] = fs[api + "Sync"];
    })
    if (debug) {
      makeCallbackToPromise(this, null, fs);
    }
  }
}

// //写流
// function writeStream(src,dir,callback){
//   let inputStream = fs.createReadStream(src, { encoding: "binary" });
//   inputStream.pipe(fs.createWriteStream(dir, { encoding: "binary" }));
//   inputStream.on("end", () => {
//     if (typeof callback == "function") {
//       callback(null, true);
//     }
//   });
//   inputStream.on("error", (err) => {
//     if (typeof callback == "function") {
//       callback(err);
//     }
//   })
//   return;
// }

class FileSystemOutput {
  //debug 开启async语法
  constructor(inputSystem, debug) {


    if (debug) {
      this.input = makeCallbackToPromise(new FileSystemInput(5000), ["wake"]);
      this.output = new ConverOutPut(true);
      Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(methodName => {
        if (methodName == "constructor") {
          return;
        }
        this[methodName + "Sync"] = makeSyncFunc(this[methodName], null, [pt], ["pt"]);
      });
    } else {
      this.input = inputSystem || new FileSystemInput(5000);
      this.output = new ConverOutPut();
      Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(methodName => {
        if (methodName == "constructor") {
          return;
        }
        this[methodName + "Sync"] = makeSyncFunc(this[methodName], null, [pt], ["pt"]);
        this[methodName] = makeCallbackFunc(this[methodName]);
      });
    }

  }

  // appendFile，如果文件不存在，会自动创建新文件  
  // 如果用writeFile，那么会删除旧文件，直接写新文件  
  //写数据
  async write(file, data, append, encode) {
    var params = {};
    if (typeof append == "boolean") {
      params.append = append
    }
    if (typeof append == "string") {
      params.encode = append
    } else if (typeof encode == "string") {
      params.encode = encode
    }


    //创建文件
    await this.create(file, true);

    if (!await this.input.isFile(file)) {
      console.error("this path is not file!");
      return;
    }

    if (params.append) {
      //flag:"a"表示追加
      await this.output.appendFile(file, data, { encoding: params.encode || 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
    } else {

      await this.output.writeFile(file, data, { encoding: params.encode || 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
    }

    this.input.purge("all", file);

    return true;

  }

  //刪除
  async remove(src) {
    if (await this.input.exists(src)) {
      if (!await this.input.isDir(src)) {
        await this.output.unlink(src); // 删除文件
        this.input.purge("all", src);
      } else {
        let fileList = await this.input.findAll(src);
        let len = fileList && fileList.length
        //尽量不要用forEach
        for (let i = 0; i < len; i++) {
          await this.remove(fileList[i]); //递归删除
        }
        await this.output.rmdir(src); //删除文件夹
        this.input.purge("all", src);
      }
    }
  }

  //拷貝,overwrite覆盖
  async copy(src, dir, overwrite) {

    let params = {};
    if (typeof overwrite == "boolean") {
      params.overwrite = overwrite;
    } else {
      params.overwrite = true;
    }

    if (await this.input.exists(src)) {

      if (!await this.input.isDir(src)) {

        if (!params.overwrite) {
          if (!await this.input.exists(dir)) {
            await this.create(dir, true);
            await this.output.copyFile(src, dir);
            this.input.purge("all", dir);
          } else {
            return false;
          }
        } else {
          //创建文件
          await this.create(dir, true);

          // let srcModify = await this.input.getModify(src);
          // let dirModify = await this.input.getModify(dir);

          //如果文件存在而且文件内容不相同时覆盖
          // if (srcModify != dirModify) {
          await this.output.copyFile(src, dir);
          this.input.purge("all", dir);
          // }
        }
      } else {
        let fileList = await this.input.findFile(src, true);
        let len = fileList || fileList.length || 0;
        let relativePath = pt.relative(src, dir);
        while (len--) {
          await this.copy(fileList[len], `${dir}/${relativePath}`, params.overwrite);
        }
      }

    } else {
      console.warn(`${src} not exists`);
      return false;
    }

    return true;;
  }

  //剪切
  async cut(src, dir, overwrite) {

    if (await this.input.exists(src)) {

      var flag = await this.copy(src, dir, overwrite);

      if (flag) {
        return await this.remove(src);
      }
    } else {
      console.warn(`${src} not exists`);
    }
    return false;

  }



  //重命名
  async rename(src, dir) {

    if (await this.input.exists(src)) {

      let path = pt.dirname(src);

      let dirName = pt.basename(dir);

      let dirpath = `${path}/${dirName}`;

      if (!await this.input.exists(dirpath)) {

        await this.output.rename(src, dirpath);

        this.input.purge("all", dirpath);
        this.input.purge("all", src);

      }
      // else{
      //   console.log(`rename fail dir:${dirpath} is exists`);
      // }

    } else {
      console.warn(`rename fail source:${src} not exists`);
    }


  }
  //必须指定是创建文件还是创建目录
  async create(createDirPath, isFile) {

    if (!createDirPath) {
      return;
    }

    if (await this.input.exists(createDirPath)) {
      return;
    }

    //最外层肯定要存在,才可以创建文件
    let parentDirPath = pt.dirname(createDirPath);

    if (parentDirPath && !await this.input.exists(parentDirPath)) {
      await this.create(parentDirPath, false);
    }
    //必须指定
    if (isFile) {

      await this.output.writeFile(createDirPath, "");
    } else {
      await this.output.mkdir(createDirPath);
    }

    this.input.purge("stat", createDirPath);


  }

}

module.exports = FileSystemOutput;

// var demoPath = "C:\\Users\\ywx533137\\Desktop\\topic";

// async function test(){
// var a = await inputfilesystem.exists("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt")
// }
// test();
var input = new FileSystemInput(5000);
var output = new FileSystemOutput(input);
output.writeSync("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt", "sdfsdfdsf", function() {
  console.log(1)
})

// .then(() => {
//   inpt.copy("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt", "C:\\Users\\ywx533137\\Desktop\\topic2\\a.txt")
// });
// fs.copyFile("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt", "C:\\Users\\ywx533137\\Desktop\\a.txt",function(){
//   console.log(111)
// })

// inpt.cut("C:\\Users\\ywx533137\\Desktop\\topic\\a.txt", "C:\\Users\\ywx533137\\Desktop\\topic2\\a.txt")