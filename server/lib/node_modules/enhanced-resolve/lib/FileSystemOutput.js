const fs = require("fs");
const pt = require("path");

const makeSyncFunc = require("./makeSyncFunc");
const makeCallbackFunc = require("./makeCallbackFunc");
const FileSystemInput = require("./FileSystemInput");
const makeCallbackToPromise = require("./makeCallbackToPromise");

class ConverOutPut {
  constructor() {
    ["mkdir", "rename", "appendFile", "writeFile", "unlink", "rmdir", "copyFile"].forEach(api => {
      this[api] = fs[api];
      this[api + "Sync"] = fs[api + "Sync"];
    });
  }
}

class FileSystemOutput {
  //debug 开启async语法
  constructor(inputSystem) {
      this.input = makeCallbackToPromise(new FileSystemInput(5000), ["wake"]);
      ["readdir", "stat", "readFile", "readlink"].forEach(type => {
        //缓存相连
        if( this.input["_"+type+"Storage"] && inputSystem &&inputSystem["_"+type+"Storage"] )
        this.input["_"+type+"Storage"] = inputSystem["_"+type+"Storage"];
      })
      this.output = makeCallbackToPromise(new ConverOutPut(true));
      Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(methodName => {
        if (methodName == "constructor") {
          return;
        }
        this[methodName + "Sync"] = makeSyncFunc(this[methodName], null, [pt], ["pt"]);
      });
  }

  // appendFile，如果文件不存在，会自动创建新文件  
  // 如果用writeFile，那么会删除旧文件，直接写新文件  
  //写数据
  async write(file, data, append, encode) {
    var params = {};
    if (typeof append == "boolean") {
      params.append = append
    }
    if (typeof append == "string") {
      params.encode = append
    } else if (typeof encode == "string") {
      params.encode = encode
    }


    //创建文件
    await this.create(file, true);

    if (!await this.input.isFile(file)) {
      console.error("this path is not file!");
      return;
    }

    if (params.append) {
      //flag:"a"表示追加
      await this.output.appendFile(file, data, { encoding: params.encode || 'utf8', mode: 438 /*=0666*/ , flag: 'a' });
    } else {

      await this.output.writeFile(file, data, { encoding: params.encode || 'utf8', mode: 438 /*=0666*/ , flag: 'w' });
    }

    this.input.purge("all", file);

    return true;

  }

  //刪除 callback处理不了for
  async remove(src) {
    if (await this.input.exists(src)) {
      if (!await this.input.isDir(src)) {
        await this.output.unlink(src); // 删除文件
        this.input.purge("all", src);
      } else {
        let fileList;
        fileList = await this.input.findAll(src);
        let len = fileList && fileList.length;
        for (let i = 0; i < len; i++) {
          await this.remove(fileList[i]); //递归删除
        }
        await this.output.rmdir(src); //删除文件夹
        this.input.purge("all", src);
      }
    }
  }

  //拷貝,overwrite覆盖
  async copy(src, dir, overwrite) {

    let params = {};
    if (typeof overwrite == "boolean") {
      params.overwrite = overwrite;
    } else {
      params.overwrite = true;
    }

    if (await this.input.exists(src)) {

      if (!await this.input.isDir(src)) {

        if (!params.overwrite) {
          if (!await this.input.exists(dir)) {
            await this.create(dir, true);
            await this.output.copyFile(src, dir);
            this.input.purge("all", dir);
          } else {
            return false;
          }
        } else {
          //创建文件
          await this.create(dir, true);

          await this.output.copyFile(src, dir);
          this.input.purge("all", dir);

        }
      } else {
        let fileList;
        fileList = await this.input.findFile(src, true);
        let len = fileList || fileList.length || 0;
        let relativePath = pt.relative(src, dir);
        while (len--) {
          await this.copy(fileList[len], `${dir}/${relativePath}`, params.overwrite);
        }
      }

    } else {
      console.warn(`${src} not exists`);
      return false;
    }

    return true;;
  }

  //剪切
  async cut(src, dir, overwrite) {

    if (await this.input.exists(src)) {

      var flag = await this.copy(src, dir, overwrite);

      if (flag) {
        return await this.remove(src);
      }
    } else {
      console.warn(`${src} not exists`);
    }
    return false;

  }



  //重命名
  async rename(src, dir) {

    if (await this.input.exists(src)) {

      let path = pt.dirname(src);

      let dirName = pt.basename(dir);

      let dirpath = `${path}/${dirName}`;

      if (!await this.input.exists(dirpath)) {

        await this.output.rename(src, dirpath);

        this.input.purge("all", dirpath);
        this.input.purge("all", src);

      }


    } else {
      console.warn(`rename fail source:${src} not exists`);
    }


  }
  //必须指定是创建文件还是创建目录
  async create(createDirPath, isFile) {

    if (!createDirPath) {
      return;
    }

    if (await this.input.exists(createDirPath)) {
      return;
    }

    //最外层肯定要存在,才可以创建文件
    let parentDirPath = pt.dirname(createDirPath);

    if (parentDirPath ) {
      if(!await this.input.exists(parentDirPath)){
        await this.create(parentDirPath, false);
      }
    }
    //必须指定
    if (isFile) {
      await this.output.writeFile(createDirPath, "");
    } else {
      await this.output.mkdir(createDirPath);
    }

    this.input.purge("stat", createDirPath);

  }

}

module.exports = FileSystemOutput;
