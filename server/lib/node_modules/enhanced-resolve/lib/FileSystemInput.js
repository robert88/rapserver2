"use strict";

const Storage = require("enhanced-resolve/lib/Storage");
const fileSystem = require("graceful-fs");
const AsyncSeries = require("enhanced-resolve/lib/AsyncSeries");
const toPath = require("enhanced-resolve/lib/toPath");
//处理路径
function join(a, b) {
  return toPath(a + "/" + b)
}


//错误消息
let throwErrorMessage = (err, api, invokeApi, path, errorCollect) => {
  let errMessage = api + "( '" + path + "' )" + invokeApi && (" invoke by " + invokeApi) + ":" + err.message;
  //外部接口
  if (typeof errorCollect == "function") {
    errorCollect(errMessage);
  }
  console.error(errMessage);
}

//检验异步是否完成
function checkFinish(counter, callBack, ret) {
  counter.num--;
  if (counter.num == 0 && typeof callBack == "function") {
    callBack(ret);
  }
}

class CachedInputFileSystem {
  constructor(duration, nocache) {

    //提供同步和异步api,带缓存,exsits已经废弃,cache控制是否缓存
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "", nocache);
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "Sync", nocache);
    });

    //提供扩展readFile api
    ["readJson", "readData"].forEach(type => {
      let handleCallback = buffer => {
        if (type == "readJson") {
          buffer = JSON.parse(buffer.toString("utf-8"));
        } else {
          buffer = buffer.toString("utf-8");
        }
        return buffer;
      }
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "Sync", handleCallback);
    });

    //提供扩展stat api
    ["getSize", "getModify", "isDir", "isFile", "exists"].forEach(type => {
      let handleCallback = data => {
        switch (type) {
          case "getSize":
            return data.size;
          case "getModify": //精确到s
            return Math.floor(data.mtimeMs / 1000) * 1000;
          case "isDir":
            return data.isDirectory();
          case "isFile":
            return data.isFile();
          case "exists":
            return typeof data == "object" ? true : data;
        }
      }
      CachedInputFileSystem.extendApi.call(this, type, "stat", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "stat", "Sync", handleCallback);
    });

    //提供扩展,依赖readdir isDir exsit 
    ["findFile", "findDir"].forEach(type => {

      let filterFile = (fileType, files) => {
        if (fileType) {
          files = files.filter(function(file) {
            return new RegExp('\\.' + fileType + '$', "i").test(file);
          });
        }

        /*del mac pc has .DS_Store file*/
        files = files.filter(function(file) {
          return file.indexOf(".DS_Store") == -1
        });

        return files;
      }

      if (!this[type]) {
        this[type] = (path, fileType, deep, callback) => {
          if (typeof fileType == "function") {
            callback = fileType;
            fileType = "";
            deep = false;
          } else if (typeof deep == "function") {
            callback = deep;
            deep = false;
          }
          if (typeof fileType == "boolean") {
            deep = fileType;
            fileType = "";
          }
          this.wake(path, deep, type == "findFile" ? true : false, data => {
            let ret = type == "findFile" ? filterFile(fileType, data) : data;
            callback(ret);
          });
        }
      }

      if (!this[type + "Sync"]) {
        this[type + "Sync"] = (path, fileType, deep) => {
          if (typeof fileType == "boolean") {
            deep = fileType;
            fileType = "";
          }
          let data = this.wakeSync(path, deep, type == "findFile" ? true : false);
          return type == "findFile" ? filterFile(fileType, data) : data;
        }
      }
    });


  }

  //绑定到cache
  static fileSystemBindCache(type, duration, syncFlag, nocache) {

    let api = type + syncFlag;

    let storageId = "_" + type + "Storage";

    if (!nocache) {
      duration = duration || 6000;
      //同步和异步提供一个storage
      if (!this[storageId]) {
        this[storageId] = new Storage(duration);
      }
    }

    if (this[api]) {
      return;
    }

    //=> this.readdir => storage => fileSystem.readdir => graceful-fs.readdir = nodejs fs.readdir
    if (syncFlag == "Sync") {
      this[api] = (path) => {
        if (nocache) {
          return fileSystem[api](path);
        } else {
          return this[storageId]["provide" + syncFlag](path, fileSystem[api].bind(fileSystem));
        }
      }
    } else {
      this[api] = (path,callback) => {
        //不需要使用缓存的，和需要使用缓存的
        if (nocache) {
          return fileSystem[api](path, callback);
        } else {
          return this[storageId]["provide" + syncFlag](path, fileSystem[api].bind(fileSystem), callback);
        }
      }
    }
  }


  //扩展简单接口
  static extendApi(type, invokeType, syncFlag, handleCallback) {

    let invokeApi = invokeType + syncFlag;
    let api = type + syncFlag;

    if (!this[invokeApi] || this[api]) {
      return;
    }

    if (syncFlag == "Sync") {
      this[api] = (path) => {
        let buffer = this[invokeApi](path, callback);
        let ret = handleCallback(buffer);
        return ret;
      }
    } else {
      this[api] = (path, callback) => {
        this[invokeApi](path, (err, buffer) => {
          //不需要报错
          if(api=="exists"){
            if(err){
              return callback(null,false);
            }
          }
          if (err) {
            callback(err);
          } else {
            try {
              buffer = handleCallback(buffer);
            } catch (e) {
              err = e;
            }
            callback(err, buffer);
          }
        });
      }
    }
  }

  //返回值可以得到ret，也可以传递ret
  wake(dir, deep, findFile, callback, ret, counter) {

    ret = ret || [];
    counter = counter || { num: 0 };
    counter.num++;
    new AsyncSeries([
      this.exists,
      this.isDir,
      this.readdir
    ], (fn, i, series) => {
      fn.call(this, dir, data => {
        //如果不存在就返回
        if (i < 2 && !data) {
          series.done(data);
          return;
        }
        series.next(data);
      }, (err) => {
        series.done(err)
      });

    }, (files) => {

      files && files.forEach((fileName) => {
        //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
        var newDir = join(dir, fileName);

        counter.num++;

        this.isDir(newDir, isDirFlag => {
          //添加文件
          if (findFile && !isDirFlag) {
            ret.push(newDir);
            //添加文件夹
          } else if (!findFile && isDirFlag) {
            ret.push(newDir);
          }
          //深度遍历
          if (deep && isDirFlag) {
            this.wake(newDir, deep, findFile, callback, ret, counter);
          }
          checkFinish(counter, callback, ret);
        }, () => {
          checkFinish(counter, callback, ret);
        })
      });

      checkFinish(counter, callback, ret);

    })

    return ret;
  }

  wakeSync(dir, deep, findFile, ret) {
    ret = ret || [];
    if (this.existsSync(dir)) {
      if (this.isDirSync(dir)) {

        let files = this.readdirSync(dir);

        files && files.forEach((fileName) => {
          //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
          var newDir = join(dir, fileName);

          let isDirFlag = this.isDirSync(newDir);

          //添加文件
          if (findFile && !isDirFlag) {
            ret.push(newDir);
            //添加文件夹
          } else if (!findFile && isDirFlag) {
            ret.push(newDir);
          }

          //深度遍历
          if (deep && isDirFlag) {
            this.wakeSync(newDir, deep, findFile, ret)
          }

        });

      }
    }
    return ret;
  }

  //清除缓存
  purge(what) {
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      this["_" + type + "Storage"].purge(what);
    })
  }

  //获取文件系统api
  getSystem() {
    return fileSystem;
  }
};

module.exports = CachedInputFileSystem;

