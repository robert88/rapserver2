"use strict";

const Storage = require("enhanced-resolve/lib/Storage");
const fileSystem = require("graceful-fs");
const AsyncSeries = require("enhanced-resolve/lib/AsyncSeries");
const toPath = require("enhanced-resolve/lib/toPath");
//处理路径
function join(a, b) {
  return toPath(a + "/" + b)
}

//检验异步是否完成
function checkFinish(counter, callBack, ret) {
  counter.num--;
  if (counter.num == 0 && typeof callBack == "function") {
    callBack(null,ret);
  }
}

//解析参数
function convertParams(path, fileType, deep, callback,filterFn){

   if (typeof fileType == "boolean") {
    filterFn = callback
    callback = deep;
    deep = fileType;
    fileType = "";
  } else if (typeof fileType == "function") {
      filterFn = deep;
      callback = fileType;
      fileType = "";
      deep = false;
  }

  if(typeof deep == "function") {
    filterFn = callback;
    callback = deep;
    deep = false;
  }

  return {path, fileType, deep, callback,filter:filterFn}
}

class CachedInputFileSystem {
  constructor(duration, nocache) {

    //提供同步和异步api,带缓存,exsits已经废弃,cache控制是否缓存
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "", nocache);
      CachedInputFileSystem.fileSystemBindCache.call(this, type, duration, "Sync", nocache);
    });

    //提供扩展readFile api
    ["readJson", "readData"].forEach(type => {
      let handleCallback = buffer => {
        if (type == "readJson") {
            try {
              buffer = JSON.parse(buffer.toString("utf-8"));
            } catch (error) {
              buffer = null;
            }

        } else {
          buffer = buffer.toString("utf-8");
        }
        return buffer;
      }
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "readFile", "Sync", handleCallback);
    });

    //提供扩展stat api
    ["getSize", "getModify", "isDir", "isFile", "exists"].forEach(type => {
      let handleCallback = data => {
        switch (type) {
          case "getSize":
            return data.size;
          case "getModify": //精确到s
            return Math.floor(data.mtimeMs / 1000) * 1000;
          case "isDir":
            return data.isDirectory();
          case "isFile":
            return data.isFile();
          case "exists":
            return typeof data == "object" ? true : data;
        }
      }
      CachedInputFileSystem.extendApi.call(this, type, "stat", "", handleCallback);
      CachedInputFileSystem.extendApi.call(this, type, "stat", "Sync", handleCallback);
    });

    //提供扩展,依赖readdir isDir exsit 
    ["findFile", "findDir","findAll"].forEach(api => {

      var typeMap = {
        "findFile":"file",
        "findDir":"dir",
        "findAll":"all"
      }

     let type = typeMap[api];

      let filterSystemfile = (file)=>{
        return file.indexOf(".DS_Store") == -1
      }


      //合并过滤器
      function convertFilter(fileType,filterFn){
        let filter;
        if(fileType){
          let filterFile = (file) => {
            return new RegExp('\\.' + fileType + '$', "i").test(file);
          }
          if(typeof filterFn=="function"){
            filter = (file,isDirFlag)=>{
              return filterFile(file,isDirFlag)&&filterFn(file)&&filterSystemfile(file);
            }
          }else{
            filter = (file)=>{
              return filterFile(file)&&filterSystemfile(file);
            }
          }
        }else{
          if(typeof filterFn=="function"){
            filter = (file,isDirFlag)=>{
              return filterFn(file,isDirFlag)&&filterSystemfile(file);
            }
          }else{
            filter = (file)=>{
              return filterSystemfile(file);
            }
          }
        }
        return filter;
      }

      if (!this[api]) {
        this[api] = (path, fileType, deep, callback,filterFn) => {

          var params;
          if(typeof path=="object"){
            params = path;
          }else{
            params = convertParams(path, fileType, deep, callback,filterFn);
          }

         let filter = convertFilter(params.fileType,params.filter);

          this.wake(params.path, params.deep, type, (err,data) => {

            if(typeof params.callback=="function"){
              params.callback(err,data);
            }

          },filter);
        }
      }

      if (!this[api + "Sync"]) {
        this[api + "Sync"] = (path, fileType, deep,filterFn) => {
          var params;
          if(typeof path=="object"){
            params = path;
          }else{
            params = convertParams(path, fileType, deep,filterFn);
          }
 
          let filter = convertFilter(params.fileType,params.callback);

          let data = this.wakeSync(path, deep, type,filter);
          return  data;
        }
      }
    });


  }

  //绑定到cache
  static fileSystemBindCache(type, duration, syncFlag, nocache) {

    let api = type + syncFlag;

    let storageId = "_" + type + "Storage";

    if (!nocache) {
      duration = duration || 6000;
      //同步和异步提供一个storage
      if (!this[storageId]) {
        this[storageId] = new Storage(duration);
      }
    }

    if (this[api]) {
      return;
    }

    //=> this.readdir => storage => fileSystem.readdir => graceful-fs.readdir = nodejs fs.readdir
    if (syncFlag == "Sync") {
      this[api] = (path) => {
        if (nocache) {
          return fileSystem[api](path);
        } else {
          return this[storageId]["provide" + syncFlag](path, fileSystem[api].bind(fileSystem));
        }
      }
    } else {
      this[api] = (path,callback) => {
        //不需要使用缓存的，和需要使用缓存的
        if (nocache) {
          return fileSystem[api](path, callback);
        } else {
          return this[storageId]["provide" + syncFlag](path, fileSystem[api].bind(fileSystem), callback);
        }
      }
    }
  }


  //扩展简单接口
  static extendApi(type, invokeType, syncFlag, handleCallback) {

    let invokeApi = invokeType + syncFlag;
    let api = type + syncFlag;

    if (!this[invokeApi] || this[api]) {
      return;
    }

    if (syncFlag == "Sync") {
      if(api=="existsSync"){
        this[api] = (path) => {
          let buffer;
          try{
             buffer = this[invokeApi](path);
          }catch(e){
            buffer = false;
          }
          let ret = handleCallback(buffer);
          return ret;
        }
      }else{
        this[api] = (path) => {
          let buffer = this[invokeApi](path);
          let ret = handleCallback(buffer);
          return ret;
        }
      }
     
    } else {
      this[api] = (path, callback) => {
        this[invokeApi](path, (err, buffer) => {
          //不需要报错
          if(api=="exists"){
            if(err){
              return callback(null,false);
            }
          }
          if (err) {
            callback(err);
          } else {
            try {
              buffer = handleCallback(buffer);
            } catch (e) {
              err = e;
            }
            callback(err, buffer);
          }
        });
      }
    }
  }

  //返回值可以得到ret，也可以传递ret
  wake(dir, deep, findFile, callback,filter, ret, counter) {

    ret = ret || [];
    counter = counter || { num: 0 };
    counter.num++;
    new AsyncSeries([
      (queue)=>{
        this.exists(dir,(err,data) => {
          if(err||data==false){
            queue.done(new Error(`ENOENT: no such file or directory, stat '${dir}'`));
            return ;
          }
          queue.next(data);
        })
      },
      (queue)=>{
        this.isDir(dir,(err,data) => {
          if(err||data==false){
            queue.done(err||new Error(`ENOENT: '${dir}' not directory`));
            return ;
          }
          queue.next(data);
        })
      },
      (queue,pervData)=>{
        this.readdir(dir,(err,data) => {
          if(err){
            queue.done(err);
            return ;
          }
          queue.next(err,data);
        })
      }
    ], (err,files) => {

      files && files.forEach((fileName) => {
        //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
        var newDir = join(dir, fileName);

        counter.num++;

        this.isDir(newDir, (err,isDirFlag) => {

          if(err){
            checkFinish(counter, callback, ret);
            return;
          }

            //添加文件
            let getFileByFindFile = findFile=="file" && !isDirFlag;
            //添加文件夹
            let getDirByFindDir = findFile=="dir" && isDirFlag

            if (findFile=="all" || getFileByFindFile || getDirByFindDir) {
              if(typeof filter=="function"){
                if(filter(newDir,isDirFlag)){
                  ret.push(newDir);
                }
              }else{
                ret.push(newDir);
              }
            } 
  
          //深度遍历
          if (deep && isDirFlag) {
            this.wake(newDir, deep, findFile, callback,filter, ret, counter);
          }
          checkFinish(counter, callback, ret);
        })
      });

      checkFinish(counter, callback, ret);

    })

  }

  wakeSync(dir, deep, findFile, filter,ret) {

    ret = ret || [];

    try {
      if (this.existsSync(dir)) {
        if (this.isDirSync(dir)) {
  
          let files = this.readdirSync(dir);
  
          files && files.forEach((fileName) => {
            //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
            var newDir = join(dir, fileName);
  
            let isDirFlag = this.isDirSync(newDir);
  
            //添加文件
            let getFileByFindFile = findFile=="file" && !isDirFlag;
            //添加文件夹
            let getDirByFindDir = findFile=="dir" && isDirFlag

            if (findFile=="all" || getFileByFindFile || getDirByFindDir) {
              if(typeof filter=="function"){
                if(filter(newDir,isDirFlag)){
                  ret.push(newDir);
                }
              }else{
                ret.push(newDir);
              }
            } 
  
            //深度遍历
            if (deep && isDirFlag) {
              this.wakeSync(newDir, deep, findFile, filter,ret)
            }
  
          });
  
        }
      }
    } catch (error) {
      console.log(error.message);
    }

    return ret;
  }

  //清除缓存
  purge(what,dir) {
    this["_" + what + "Storage"].purge(dir);
  }

  //获取文件系统api
  getSystem() {
    return fileSystem;
  }
};

module.exports = CachedInputFileSystem;
