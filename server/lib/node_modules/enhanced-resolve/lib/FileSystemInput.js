"use strict";

const Storage = require("enhanced-resolve/lib/Storage");
const fileSystem = require("graceful-fs");
const AsyncSeries = require("enhanced-resolve/lib/AsyncSeries");
const toPath = require("enhanced-resolve/lib/toPath");
const toReg = require("./toReg");
const makeSyncFunc = require("./makeSyncFunc");
const parseCallbackEndArg = require("./parseCallbackEndArg");


//错误消息
let throwErrorMessage = (err, api, invokeApi, path, errorCollect) => {
  let errMessage = api + "( '" + path + "' )" + invokeApi && (" invoke by " + invokeApi) + ":" + err.message;
  //外部接口
  if (typeof errorCollect == "function") {
    errorCollect(errMessage);
  }
  console.error(errMessage);
}

//检验异步是否完成
function checkFinish(counter, callBack, ret) {
  counter.num--;
  if (counter.num == 0 && typeof callBack == "function") {
    callBack(ret);
  }
}


let filterFile = (fileType, files) => {

    files = files.filter(function(file) {
      let f =  true;
       if (fileType) {
        f = new RegExp( toReg.call(fileType), "i").test(file)
      }
      /*not include mac pc  .DS_Store file*/
      return f && file.indexOf(".DS_Store") == -1;
    });
  
  return files;
}

module.exports = class FileSystemInput {

  constructor(duration, nocache) {

    //提供同步和异步api,带缓存,exsits已经废弃,cache控制是否缓存
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      FileSystemInput.filesystemBind.call(this, type, duration, "", nocache);
    });

    //提供扩展readFile api
    ["readJson", "readData"].forEach(type => {
      let handleCallback = buffer => {
        if (type == "readJson") {
          buffer = JSON.parse(buffer.toString("utf-8"));
        } else {
          buffer = buffer.toString("utf-8");
        }
        return buffer;
      }
      FileSystemInput.extendApi.call(this, type, "readFile", "", handleCallback);
    });

    //提供扩展stat api
    ["getSize", "getModify", "isDir", "isFile", "exists"].forEach(type => {
      let handleCallback = data => {
        switch (type) {
          case "getSize":
            return data.size;
          case "getModify": //精确到s
            return Math.floor(data.mtimeMs / 1000) * 1000;
          case "isDir":
            return data.isDirectory();
          case "isFile":
            return data.isFile();
          case "exists":
            return typeof data == "object" ? true : data;
        }
      }
      FileSystemInput.extendApi.call(this, type, "stat", "", handleCallback);
    });

    //提供扩展,依赖readdir isDir exsit 
    ["findFile", "findDir"].forEach(type => {

        this[type] = async () => {

         let {path, fileType, deep, callback} =  parseCallbackEndArg(arguments,"path, fileType, deep, callback","boolean,function");

          let data =  await this.wake(path, deep, type == "findFile" ? true : false);

          if (typeof callback == "function") { callback(ret); }

          let ret = type == "findFile" ? filterFile(fileType, data) : data;

          return ret;
        }
      
    });


  }

  //绑定到cache
  static filesystemBind(type, duration, nocache) {

    let api = type;

    let storageId = "_" + type + "Storage";

    if (!nocache) {

      duration = duration || 5000;

      //同步和异步提供一个storage
      if (!this[storageId]) {
        this[storageId] = new Storage(duration);
      }

      //=> this.readdir => storage => fileSystem.readdir => graceful-fs.readdir = nodejs fs.readdir
      this[api] = async (path, callback) => {
        let ret = await this[storageId].provide(path, fileSystem[api].bind(fileSystem));
        if (typeof callback == "function") { callback(ret); }
        return ret;
      }

    } else {
      this[api] = async (path, callback) => {
        let ret = await fileSystem[api](path);
        if (typeof callback == "function") { callback(ret); }
        return ret;
      }
    }

    //创建同步代码
    this[api + "Sync"] = makeSyncFunc(this[api]);

  }

  //扩展简单接口
  static extendApi(type, invokeType, handleCallback) {

    let invokeApi = invokeType;
    let api = type;

    if (this[invokeApi] && !this[api]) {

      this[api] = async (path, callback) => {

        let ret;

        let buffer = await this[invokeApi](path);

        //JSON.parse的错误使用try
        try {
          ret = handleCallback(buffer);
        } catch (err) {

        }

        if (typeof callback == "function") { callback(ret); }

        return ret;
      }
    
      //创建同步代码
      this[api + "Sync"] = makeSyncFunc(this[api]);
    }

  }


  //返回值可以得到ret，也可以传递ret

  async wake(dir, deep, findFile, ret, callback) {

    ret = ret || [];

    if (await this.exists(dir)) {
      if (await this.isDir(dir)) {

        let files = await this.readdir(dir);

        files && files.forEach(async (fileName) => {
          //直接连接的话路径和文件中间不需要“/”，路径和路径需要“/”，path.join可以解决这个问题
          var newDir = toPath(dir + "/" + fileName);

          let isDirFlag = await this.isDir(newDir);

          //添加文件
          if (findFile && !isDirFlag) {
            ret.push(newDir);
            //添加文件夹
          } else if (!findFile && isDirFlag) {
            ret.push(newDir);
          }

          //深度遍历
          if (deep && isDirFlag) {
            await this.wake(newDir, deep, findFile, ret);
          }

        });

      }
    }

    if(typeof callback=="function"){
      callback(ret);
    }

    return ret;
  }

  //清除缓存
  purge(what) {
    ["readdir", "stat", "readFile", "readlink"].forEach(type => {
      this["_" + type + "Storage"].purge(what);
    })
  }

  //获取文件系统api
  getSystem() {
    return fileSystem;
  }
};